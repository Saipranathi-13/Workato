What is Workato?
It is defined with 2 words called work and automation. Workato is essentially an enterprise garde automation platform
in It finance and all the different departments we can use waorkato and we can build automation.Workato is essentially serverless platform
Workato, It allows users to automate business processess like this in a very usual visual way without a developer skill set.
This is what refer to low code. no code
Tools in workato:
ETL/ELT: involving bulk. Transfer of data could be thousands of records or millions of records.
API Management: can expose your integration to external parties or apps if required, where workato
can also create workflow.
conversational bots are able to build and deploy interactive work bots in the workplace.
Workato environment- workato workspaces- different integrations that will be building our recipes.
1. Dev Workspaces: developing recipes in development team
2. QA workspace: QA team to check your recipe 
3. Prod workspace: all of your instances are connected to your production environment.
Recipes can be migrated from one account to another via the Recipe Lifecycle Management tool.
Each Workato user may be given access to multiple environment.
Recipe is very similar to like a cookbook. It is logical steps that will be executed to meet your integration.
recipe can be create using 2 methods. 1. our own 2. cloning
3 main ingredients of a recipe
1. Connections: all applications need to have connected to your recipe.
2. Trigger: can only be 1, what your recipe will listen for, or this is what will tell your recipe to kick start.
3. actions: all of the steps that you would want to execute in your recipe. no limit for actions.
if we dont have trigger then recipe will not start.
2 ways to share recipe:
1. List recipe: we have list of the recipes
2. Private sharing link: sharing link it will be private.
Connections: when we are connect to other applications inside worato. it allows you to pick authentication options
basic auth, Oauth2, API tokens, custom protocols.It is simple like username and password.
Triggers have different types:
1. Real-time: implemented with web hooks
2. Polling- implemented with web hooks
3. Scheduled- scheduling the time
Trigger events are delivered in the same order as events were created or modified in theapp- workato cursors.
Trigger conditions: you are able to define more information in your triggers if you do not want to process all of the records.
recipe steps can be simple actions, or control flow statements that help you describe business logic.
what work does your recipe do:
1. actions types- adding, searching,updating, deleting
2. control- conditions, loops,error monitor(try-catch), stop, Recipe functions.
3. Data- single, Batch/list.
OOB(out-of-the-box) actions:
   create, update,upsert,search,get delete.
Data mapping- mapping, formulas, lookups.
Recipe data box, this is a placeholder for the information from your previous steps.
data pills: information in recipe box which we have in small boxes with data.
.slice(start_index,length)- get part of a string.
Data types: data pills can be of the following 
string, integer, number, object, date, date time, boolean, Array.list.
Formula Mode- 
split: split up a string based on a delimiter
First: Returns the first iteam in the list.
Upcase: converts the entire string into upper case.
Testing ensures your automation's behavior and data processing are correct.
The Operations hub dashboard, accessed through the navigation bar, allows you to visualize real-time data pertaining to the recipes and connections in your Workato account at a glance.
If the recipe is edited and saved, the recipe will increment to a new version.
Types of recipe changes : 
   1. schema changes: changing the schema of the recipe
   2. logic changes: changing the logic of the recipe
3 parts of the setting tab
   1. general: you can choose the concurrency number depending on the number of jobs the recipe processes simultaneously. You can also select a higher number for high-volume transactions.
   2. data retention: you can set a data retention policy as instructed by your organization or team.
   3. sharing: you can list your recipe in the Workato Community Library.
Running a test job requires:
   A fully configured trigger
   Valid data mappings
   Valid connections
The Workato Community Library contains integrations and workflow automations built by the Workato community. Find, clone, and personalize them to your specific needs.
Intelligent business processes:
1. Enterprise-grade foundation
2. citizen integrators
3. Conversational integration
4. It governance 
5. Extensible platform
Levels of functionality:
   1. Data integration: data integration without any manual effort and without data duplication.
   2. Process integration: such as workflow automation, which enables u to create efficent business processes across multiple applications.
   3. Experience integration: can talk to your applications or business processes to send important notifications or carry out commands on your behalf.
Intelligent process automation: It is a workflow that starts with a trigger event and a list of one or more actions.
Workato recipe allows you to automate processes b/w the tools, systems, and apps that you use.
Assets include smart folders for Recipes and Connections you've created in your account. You can also access your Trash bin from here.
Projects help you create, organize, and manage your automation lifecycle to meet your business goals by grouping people and assets that work together.
The Operations hub dashboard allows users to visualize real-time data pertaining to the recipes and connections in their Workato account at a glance. It provides key insights, analytics, and actions so you can discover and resolve issues faster.
Workato Tools help perform three main functions: Build recipes, connect apps and collaborate and manage recipes
Recipes are automated workflows built by users that can span multiple applications and are simple yet powerful. 
The Workato recipe editor is the powerhouse of the Workato platform and the main area of focus throughout this course.










Automation pro 2



Conditional Actions: set a condition within your recipe to better define the overall workflow processing logic.
Conditional Actions will only be carried out only if the specified condition is true.
2 types of conditional actions:
1. IF- will only be executed when the conditions are met.
2. IF-ELSE- if conditions are true, actions within the if block will be executed . otherwise if false the actions within the else block will be executed.
Workato will work on nested conditional actions.
 we have 3 different fileds to configure conditional actions
1. data field: typically mapped by a dynamic data pill
2. condition: depends on data type 
3. value: mapped by a fixed input value.
conditions are sensitive to data types.
common use cases:
1. Deduplication logic: when you sync over information to other, there would not be the same record combined. 
2. stopping the recipe
3. invoking different function recipes.
4. setting up notifications for different error messages.
Error Handling: used to monitor actions and retry failed steps
configuring error monitoring and handling:
1. retry the sequence of actions
2. take remedial actions
we can retry 3 times in the monitor action block.
common mistakes:
1. using too much try/catch
2. neglecting to mark the job as "failed" when using the stop action
We do not have limit to create the nested monitor blocks.
Maximum error retries that can use is 3 times and can also change the interval b/w these 3 tries. it can be 6 or 4 or 1 seconds.
Repeat Actions: Loop through a list of records
The repeat action is useful for going through that certain batch of records.
Repeat action is useful to go through each item in your batch dispatch.
common use cases:
1. csv/database rows
2. order line items
3. any type of list/array
Variables: placeholder to store data used to refer the information and also we can manipulate the information
common use cases of variables:
Transforming data
   Formulas- reducing complexity with variables
   Lists- simplify operations and actions on muti-row outputs of lists
           Basic Lists: rows are self-contained where all the information required is explicitly expressed in each filed
            nested list: details of the rows in a paremt list are contained in a separate child list.
Mapping data in List
   1. Directly into an action without list processing:
   2. Into an action with a repeat step 
   3. into an action with a list input
Processing list in recipes:
    1. search records in an application(search related action)
    2. Get list of records
    3. Processing CSV rows
An uninitialized variable has a value of null or nill.
Environment properties can be re-used in recipes. 
Default value of a variable with a type of "integer" if it is not specified by the user- nill

Lookup tables: mini-database table
organized like a database table with columns and rows of data. 
common use cases:
static reference data
temporary logs/error handling
compiling data for daily reports
mistakes: 
storing large amounts of data
storing lookup data that already exists in source systems.
The total no of rows we can retrieve from a lookup table: 10,000


Every application consists of 3 pillars:
    1. Data storage: enables u to store data in data tables and access your data through the workflow app connector.
    2. The user interface for business users in Workflow apps portal. It is partially generated by Workato, and partially customized by creating Pages.
    3. Business Logic: The logic of the application, implemented in Workato recipes.
Data tables: Workato Data Tables provide robust, scalable, and secure structured data storage in Workato. It enables you to define data tables in projects.


Technical beginner:

create intelligent process automation workflows to remove the need for labor and manual tasks this increases the predictability of services as well as reduces error from manual tasks.
Basic building blocks:
   1. Trigger event: by using conditions as part of the workflow logic to determine the action that needs to be taken.
   2. Actions: data points of each item in the list to determine which best suits your needs this is called a repeat action: as u repeat a set of steps to determine actions that are performed.
   3. End
every recipe works on its own container.
Workbot lets u build customized bots to automate ur workflows.
projects are flexible way to organize ur automation.
dependences: relation ship b/w the connections and recipes
connections: secure way to give access to ur business applications
it notifies an ops team abount the escalated issuse using pagerduty
authentication grants ur team access to the data of your business applications
each app provides different ways to authenticate
basic-username and password
Triggers are events that kick off a recipe.Triggers are time-based, event-based.
Actions are set of tasks u want to automate.
Mappings control the data flow in automation.
API: Application Programming Interface. This isthe software layer between two applications that allows them to talk to one another. See this post from a competitor, which explains APIs well.
API Management is the practice of cataloguing and documenting APIs and making them available for use within a company and by it's suppliers
and/or customers. This also involves governance and security considerations.
Applicant Tracking System, (Examples: Greenhouse, Oracle Taleo). Prospects and customers using Workato for rapid employee growth will likely want to build recipes for their ATS.
BA or BSA Business Analyst or Business Systems Analyst. These describe job titles that are our most common ICP for our direct platform offering. 
3 fundamental use cases for automation: 
   1. Data consistency:
   2. multi step process: 
   3. composite services:




Workato fit 101

The business process: the set of actions and activities that different people or different roles doing task to get an outcome.
Integration: allows data to flow b/w different business applications.(Accessing data from apps)
Automation:(process & task focused)  It is the technology-enabled automation of tasks or business processes
How integration and automation work together: Integration at the core of automation
Integration (data automation)-->Task automation--> Process automation--> Enterprise automation.
Different types of integration:
         Swivel chain integration(Fully manual): their is a person they lookup data from one application and re-type the data in other application.
         File-based integration: (80% comapny's use this apporach) export the data one system and store that data in csv file and then converts into the file which the other system can read.
         API-based integration: one system system send the data by using API and then the data can be in any format to the other application in that application we can update the data.
         UI-based integration: UI will lookup data in one application screen and then enter data in other application screen.
         Database integration: effectively connect to the data base application and select the data and we can push the data directly to the other applications database.
         Mixed interface Integration: get the data from one application and transfer the data into file and then push the data into other application.
Problems in using custom scripts and code:
         unreliable
         difficult to support
         very time intensive
         like jenga-can easily crumble 
         can't easily monitor
         limited experts understand it
Enterprise Automation: It is a platform category aimed at combining experience,process, and data integration capadilities in a single low-code platfome in order to provide both technical and non-technical users the ability to rapidly automate end-to-end business processes.

Recipe function: type of a recipe that can be called from another recipe.
This helps to reduce the length of your recipes by separating a repeatable set of actions.
Use of recipe function: can save time and make recipe creation easy
features of recipe functions:
1. The child can respond back to the parent recipe with relevant data that would be useful for the rest of the recipe.
When the parent recipe is waiting for data from the child recipe, we call it a "Synchronous execution".
while creating recipe function we will have the
Parameters schema: Define data passed in from parent recipe to pass on to the child or otherwise known as recipe function.
result schema: configure data to return to parent recipe.
recipe functions can be used in Error handling, New customer workflow, new It ticket helpdesk,rehire workflow, reusable update employee workflow.

Enterprise Workbot for slack

Workbot is a bot platform that looks & feels like a custom-built internal app. It allows you to eliminate app-hopping and bridge your business applications into one interface,right within slack.
Instead of switching b/w multiple windows, bots provide a minimalistic presentation of critical actions in a single pane of glass.
How does work bot works:
      1. connect to any app with APIs like REST and SOAP, databases,or file systems.
      2. Define the trigger
      3. Define the actions
      4. Execute the workflow
2 simple kinds of bots:
         1. Click-navigation chatbot: involoves through a consistent and predictable UI to execute tasks.
         2. Natural language chatbots:which utilize AI from tools and engines like Google Dialogflow, Amazon lex, and IBM wtason to provide a conversational experience in executing tasks.
Accelerators are Workato's pre-packaged solutions for common automations with high resuability across industries.
Lead Bot: An intuitive bot whose goal is to deliver, review,qualify and assign leads-all with a custom UX designed for speed.
Lead bot helps in:
      Book more meetings
      connect with leads
      create a top-tier experience for new customers
Firefighter Bot: a helpful assistant focused on facilitating internal requests.
      putting out fires
      solve many small problems at once
using this bot we can set automatic reminders and escalations and create and approve requests, all without leaving your slack window.
this is more used for IT helpdesk and lifecycle management.
HR bot: helping you execute end-to-end hiring, onboarding and other HR processess.
This bot makes it easy to review feedback from candidate interview panels that would normally live within a recuriting systems.
3-Worded new command trigger: to uniquely identify & execute wrokbot for slack recipes for their specific workflows.
Slash command is a trigger that's baked into a 3-worded new command trigger. this menas that a workbot recipe can be trigger from both slack interactive components such as slack buttons, select menus, Datapickers etc. and by typing slash "/" followed by the command name.
Global shortcut: similar to a slash command can ne invoked anywhere in slack execute a workflow that doesn.t require context.
Message shortcut: useful in workflows where the starting point is a slack message you'd like to extract with other background details.
The New Dynamic Menu Event Trigger is used to dynamically present a list of options in a select menu based on what users type in real time.
      Trigger that is always paired with a return menu options action.
      Always involves a minimum of 2 recipes
      A parent recipe that creates the select menu.
      A child recipe is invoked from the parent recipe to perform three important things.
The child recipe:
         1. It monitors for dynamic menu events from dynamic menus in modals or trigger parameters.
         2. It dynamically retrieves menu options from backend systems, based on the type-ahead and any search parameters
         3. It returns the menu options to the primary or parent recipe, which will the continue the workflow.
Tips to improve your post:
         1. slack markdown and emojis
         2. Attachement Message field
         3. Attachment colors
         4. Attachment title links



Batch/Bulk processing:
It is a method of running high-volume,repetitive data jobs.
The batch method allows users to process data with little or no use interaction.
Why batch processing:
      efficient way of moving large volumes of data across systems.
Use cases:
      Business intelligence
      case management
      order management
      Marketing operations
      file upload
      Multi-instamce sync
Batch triggers:
Batching enables you to process multiple rows of data or multiple records with just one job.
Batch actions are typically of the form:
      create batch
      update batch
      upsert batch records: it updates if the record exists or creates, if the record doesn't exist.
               Updates or creates multiple records in a single action
               requires a list of records with id's to be updated as the input
Bulk Actions: It ensures that you can do large quantities of processing while minimizing the users wait time.
Useful in business processes that requires mass data transcations and syncing data information.
Difference b/w batch and bulk
         1. when using batch processing it can control the no of records or data to be used by configuring the batch size.
         2. For bulk actions, it pushes large amounts of data in one go.
create bulk:
      create list of new records in a single action
      Field configuration allows data mappings for creation of records
Upsert bulk:
      create list of new records in a single actions and update list of exisiting records
      A primary key such as external ID is required to determine whether a record exists



CSV tools by Workato


CSV file overview:
Comma separated values(CSV) file:this files are the one of the most commonly used files for exchanging information b/w system architecutures.
      Text file
      Stores tabular data
      Human-readable plain text
      Each line=one data record
      same no of fields
      separated by comma
Delimiters: A delimiter is a sequence of one or more characters for specifying the boundary between separate, independent regions in plain text, mathematical expressions or other data streams. 
Enclosing characters: You can also specify enclosing characters that mark both the start and end of a region of text, such as single or double quotation marks.
CSV use cases in workato: Keep track of client calls
To convert CSV content into usable datapills, you can parse them with Workato's built-in CSV parser or try a connector-specific CSV parser.
Certain connectors have triggers/actions that can parse CSV content. These are called connector-specific parsers or external parsers.
csv tools by workato:Workato tool available as an action in any recipe and can parse up to 50k rows.
Parsing with CSV Tools by Workato: 

Working with databases: 

All database connectors give you the option to connect through an on-prem agent.
To connect to a relational database in a virtual machine, we need:
         username and password
         windows authentication
         hostname + port of the database
To interact with your tables, the lowest set of privileges of the connected user should be set.
Connected user requires at least select privileges for chosen database.
Different triggers in database:
         New row
         New row/updated row(batch)
         New row via custom sql
         New row/updated row via custom SQL: using sql queries
         Scheduled query(batch): this will execute sql query in specified schedule
RDBMS apps can dispatch in batch/bulk processes. 
Triggers with batch/bulk processes can be used when dealing with hundrends or thousands of records.
Performing CRUD(create, read,update,delete) operations:
other that crud we have select and execute



RecipeOps:


Recipe Ops is a connector in Workato that enables the building of recipes to monitor and manage other recipes. Workato customers use RecipeOps to automate monitoring and recovery from errors and for other administrative functions.

Recipe Watch(Status and health):
      Monitor mission-critical automation
      Automatically start/stop during planned downtimes
      Status reporting
Automated Recovery(reduce unplanned downtime)
      Reduce unplanned downtime
      Custom workflows based on error types and messages
      Lossless pause, resume, auto-retry
Intelligent operations(rule based ops and bots):
      Custom rule-based bots, reporting, recovering
      Workflows when new collaborators join
HandsFree(Eliminate human labar)
Triggers in recipeops:
         Failed Jobs: The failed job trigger is able to monitor all active recipes or selected recipes, for failed jobs. This is useful in ensuring that key recipes are monitored and corrective actions, including notifications, can be automated.
         Recipe Started/Stopped by Workato/User: This trigger allows users to build contingencies for key recipes that should/not be started/stopped. For example, enforce a restart logic or setup customer escalation policies to inform key personnel when the recipe has been stopped.
         Account Connected/Disconnected: These trigger monitors apps connected/disconnected in Workato. On occasions, app connections can become invalid due to several reasons:
                        app credentials were changed and the connection was not updated correspondingly in Workato
                        connected user doesn't have the right set of permissions to read/write selected records
                        permissions of the connected user were changed to a reduced scope
         Customer Usage Threshold Reached: This will monitor all customers and triggers when a customer reaches thresholds of their usage limits for tasks according to their plan. Users will receive an event for every 10% of usage.
         Member Invitation Accepted: For Workato users who are team owners, admins, or have been given permissions to, they can monitor their collaborators who they have invited in their Team workspace.
         Packaged Deployed: Using this trigger will receive a notification when a package is deployed in your Workato Account.
Actions in recipeops:
            Stop/Start Recipe: This allows specified recipes to be started/stopped. A single recipe can be selected from a picklist. Alternatively, a selected recipe can be specified by ID.
            Get Account Details: Get information about the Workato account, such as subscription plan type, allotted and remaining transaction counts, recipe, and connection counts.
            Search Job History: This action lists the last 100 jobs by default. This action lets
                                 Users filter by job status e.g. show failed jobs only
                                 Users filter by date range as well
            Rerun Jobs: Using RecipeOps can help to rerun singular or bulk jobs in a specified recipe. This action requires a Job ID to be rerun. 
                        Usually these datapill can be retrieved from a RecipeOps trigger/action.
                        Dynamic list - Use this if the number of items or their content depends on another list. This is the most common input mode used. 
                        Fixed list - Use this if you know the total number of items and their content. This input mode is infrequently used.
                        List Connection: This action is useful to display the details of a specific connection or a list of connections. Connections can be filtered by name or recipe. Result is limited to 1000 recently updated connections.

HTTP connector


Workato HTTP Connector enables you to build integrations with any cloud applications that have an HTTP-based API and to build additional actions on the Workato platform.
Pros and cons of HTTP conector:
     Pro: The HTTP connectors enables quick connectivity to custom applications or application connections not yet available through workato.
      Cons: connectors is unable to handle certain complex API functionality.
      Pro: It is suitable for one-off requirements to connect to add/or perform an action within an application.
      Cons: Actions are not scalable.
There are two common types of web service APIs: Simple Object Access Protocol (SOAP) and Representational State Transfer (REST).
Workato communicates with any API using HTTP Connector:
      connections & Authorization
      request
      response
HTTP actions enable you to create custom requests and response schemas for HTTP-based APIs.
After you have setup your HTTP connection, you can now configure HTTP actions. Within the HTTP connector, you have the choice of two actions:
            Send request
            Send request and wait for response (private preview)



Recipe Lifecycle Management for Environments 

It is a series of steps your team can follow, from discovering automation ideas too implement and running workflows in production.
Help streamline end-to-end automation delivery process
Applies to any project regardless of methodology
Benefits of Recipe life cycle management:
      Improve productivity through effective collaboration
      Enhance business responsivesmess to change
      Increase business value hrough improved quality
Environment strategy: It is all about planning and structuring different enviroments. 
Good environmrnt strategy helps multiple teams collaborate efficiently.
benifits of Environment strategy:
      We recommend having atleast 3 seperate environments for Dev, Test, and Production
      Improve resilience by managing disruptions
      Enhance security and compliance
      Better control with seamless handover b/w teams
      Facilitate training of new members in a production-like environment
Environment strategy:
      Define lifecycle stages
      Identify individual roles and responsibilities
      Identify how many different teams you need to support
Decentralized Governance:We have a sales team and finance team building recipes independently for compliance reasons.
You can set up a seperate development, test and production environment for each group.

                     Pros                                    Cons

            Seperation of concerns                     Duplication of efforts

            Enhanced control                           Enforcing best practices across teams

Centralized Governance: It is to segment one or more team accounts to allow access to diff folders by diff teams.


                     Pros                                             Cons

            Consistent governance processes                     Role management

            Prevents shadow IT                                  Increased audit requirements

Roles and responsibilities:

                        Applicate Admin                        end-to-end change owneeship
Change Owner            Application Support                    Implement and test changes
                        Functional Analyst                     can create/edit recipes in non-production environment
                        Eg: HR Analyst                         Cannot to create connections
                                                               

                                                               
                        Business SME                           Assess and authorize changes
Change Manager          Process Analyst                        Coodination and communication
                        Business Analyst                       Oversight and ownership of the full worakto platform
                        Eg:Platform Admin                      Full access to platform and manages core security configuration

                                                               
                        Operations lead                        Represent change Advisory Board
Change Approver         COE lead                               Maintain devlopment standards
                        Solution Architect                     


                       Operations Engineer                    Plan and manage production releases
Release Manager        COE lead                               Rollback and communication planning
                       Application Admin                      Can import/export recipes b/w environements
                       Eg: HR Operations                      Can create/update recipes in production environment



                       Technical Business SME                  Monitor and report incidents
Incident Manager       Application Admin                       Support problem resolution
                       Centralized IT team                     Can view job reports in prodution enviroment
                       Eg: HR Manager                          Cannot create/edit recipes in prodution environment 

Recipe Lifecycle stages:
         Plan for building and operating automations
         Defines a set of steps to help deliver automations
         Improve teams overall effectiveness
Seamless collaboration with RLCM:
         Span multiple teams from differnr business units
         Manage and track tasks when you have several projects moving together
         vital to cohesive organization working towards common goal

RLCM:
      Discover: change management
                     Adapt change and release management processes
                     intake and manage automation projects
                     Track and manage automation change requests as independent projects.
                     Prioritize change requests
                     identify and enforce project workflow to best suit organization
                     Review and approval stages for each change
      Discover: Dependency Management
                     Manage dependencies b/w recipes, connections, lookup tables etc
                     critical function of managing automation lifecycles
                     Analyze and asses impact on shared assets before making changes
                     Coordinate shared asset changes such as calloble recipes or custom connectors.
                     Identify releases that will deploy shared asset changes in production


      Implement: Recipe Review
                     Essential checkpoint
                     Enforce standards
                     Adhere to security guidelines      
                     Ensure quality deliverables
                     Ensure compliance to security standards, naming conventions, design best practices and more
                     Facilitate recipe review through a pull request(PR) feature of an external version control system.
                     Provide review comments or request changes, and adjudicate changes for next lifecycle stage
      Implement: Testing
                     Inadequate testing can cause productivity loss, system outages, and data inconsistencies
                     Risk being out of compliance with laws, internal policies or regulatory requirements.
                     Test recipes before going live
                     Check recipes for defects and fitness for business requirements to ensure they perform efficiently
                     Have a dedicated Quality Assurance team for testing.
                     Devlopers can test recipes to perform functional testing
                     One or more business stakeholders perform functional testing
                     Validate automation addresses user expectations.
      Implement: Testing best practices
                     Understand end-to-end workflow and applications involved
                     Identify different test scenarios
                     test scenarios should provide adequate coverage including error handling validation
                     Test cases should include test data, preconditions, and expected outcomes
                     Identify and plan for non-functional testing needs
                     Test every change
      Implement: Regression Testing 
                      Design automations using callable recipes to perform business logic
                      Group multiple test recipes in a test suite for use in CI/CD(continous integration and delivery) pipeline
      Implement: versioning
                      Every time you save a recipe a new recipe version is created
                      optonally use external version control systems to maintain environment snapshots
                      Directly map workato packages in external version control systems. 
                      Avoid making recipe changes outside of workato platform


      Operate: Automation
                  Lookup tables maintain lists of important recipes
                  Monitor status of critical recipes with recipeOps
                  Execute steps of restart recipes or send notifications with recipeOps if ctitical errors encountered
                  Manage third-party application planned downtime
                  Maintain schedule in lookup table
                  Automatically stop and start recipes for maintenance window
                  Restart recipes to consume any unprocesses business events

                     Automated Monitoring:
                                 Automated monitoring of mission-critical automations with recipeops
                                 Automatically manage planned downtime
                                 status alerts
                     Automated Recovery:
                                 Zero event loss automation pause,resume, and auto-retries
                                 Business processcentric custom recovery workflow
                                 Workbot based reporting recovery
 Automated Monitoring +  Automated Recovery = Intelligent Operations
                     Intelligent Operations:
                                 Increase operational uptime
                                 Discover and troubleshoot operational and business process issues faster
                                 Increased stakeholders trust
                                 Automate workflows to manage platform collaborators

      Operate: Auditing
                     Regular compliamce audits of production environments
                     Governance and oversight ensures only approved changes are promoted to production
                     Regular track changes made to recipes, connections, folders, and more

Manifest: It is a record of all the selected recipes and their dependencies.
Exported package includes all selected recipes and their dependencies need for automation to work
Release types:
            Major:
                  New automation or major enhancements
                  All assets are built,test and implemented together
                  Regressing tested to ensure zero impact on existing bevaior
            Minor:
                  Includes only changes assets since last release
                  Limited testing requirements
                  Minimal impact on existing business process behavior
            Bug-fix:
                  Production issues fixed with configuration changes
                  Production issues fixed with recipe changes

Release planning:
            Build & test Plan
                        Approved changes
                        test results
                        user acceptance criteria
            Deployement plan
                        Release package
                        Rollback plan
                        Production freeze schedule
            validation plan
                        Deployment approval
                        Release success validation
            communication plan
                         End-user communication
                         End-user training
            Review plan
                         Monitor release
                         improve metrics
                         Lessons learnt from feedback for next release


Continous Integration(CI):Continuous integration (CI) is a software development practice that involves regularly integrating code changes into a shared repository, often multiple times a day. 
Continous Delivery(CD): This involves the seamless and automated delivery of software in a small and incremental way. 
     Benefits:
            Faster release cycles
            Deliver quality automations
      Goal:
            Automate way teams build,test and package automations
            helps automate delivery to multiple enviroments
            Easier for teams to coordinate deployment,run quality controld on release, and reduce errors.

GEARS Framework


The GEARS Framework is a collection of guides, best practices, and other assets that help you build, maintain and mature your automation practice. 
The Five Domains of GEARS

GEARS is an acronym that represents the five different domains that make up the framework. 
                           Govern
                           Enable
                           Adopt
                           Run
                           Scale
Challenges in scaling automation:
Scaling an automation practice typically faces both organizational and technical challenges.
               Automation Opportunities & delivery backlog: Opportunities for automation are growing everyday with newer technologies and so too are backlogs for delivery teams
               Availability of specialized resources: specialized integration resources are becoming more difficult to find and therefore scaling up on legacy integration tools becomes difficult
               Decentralized DevOps & product teams: Product focused teams are being formed to specialize in specifif business processes and data
               Solution Delivery budgets and Timelines: Expectations for increses use of technology are combined with downward pressure on delivery timelines and budgets.
Three Steps to Building an Automation Practice
      Create a strong foundation: Establish security policies, quality assurance and automation lifecycle processes to build and operate automation projects 
                                  without any disruption(Govern, Run).
      Build a culture of automation: Create a well-defined enablement approach to help people with different skills build automations. Support them through an onboarding process, 
                                     and foster adoption by getting more people in the organization to build automations and unlock project delivery capacity(Adopt, Enable).
      Harness value at scale: Begin to scale by ensuring each initiative and automation is aligned with the enterprise strategy and pushes the business goals forward(scale). 
                              This is where you start to report the business impact of automation and continuously improve the different business processes to become more efficient.
Each domain of the framework can be broken down into actionable building blocks called Levers
by applying Recipe Lifecycle Management Processes.

GOVERN          Intake & Prioritization     Architecture & Design        Security & Administration               Automation Lifecycle Management

ENABLE          Resource Center             Onboarding & Education       Accelerators & Reusable Assets          Automation Lifecycle Management      Automation              Business 
                                                                                                                                                        HQ                   Technology
ADOPT           Value Reporting             Onboarding & Education       Champions & Evangelism                  Community                                                    Strategy

RUN             Project Execution           Capacity Planning           Support Model                            Operations

SCALE           Automation Maturity          Automation Discovery             Enterprise Automation Ecosystem
                  & Improvement

Govern: Establish governance to ensure security and compliance.
Enable: Empower teams through training and tools.
Adopt: Promote adoption of automation within the organization.
Run: Manage day-to-day operations, monitoring workflows.
Scale: Expand automation across teams and processes.


GOVERN
      Intake & prioritization involve two parts. First, an intake process for stakeholders to submit new project requests, automation ideas, and improvement suggestions. A well-defined project request or intake process 
                  eliminates back and forth between different stakeholders and streamlines collaboration.
                              Second, is the prioritization of automation requests. It provides a framework for defining the business value and complexity of requests so that everyone has a shared understanding of a project's priority and success metrics. 
                              Intake & prioritization allows teams to organize and update their backlog to work on the highest business impact requests and creates cross-functional visibility where all stakeholders and business teams know the status of their requests.
      Architecture & Design refers to the practice of defining the architectural styles and design principles that builders should follow when building new Workato Assets. 
                            Finally, in this stage, the Automation HQ team should identify the potentially reusable assets or common services that will feed into the “Accelerators & reusable assets” lever.
      Security & administration focuses on establishing guardrails that extend the freedom to build automations without opening the organization to unmanaged risks to its apps and data. 
                                 User-owned security and administration aspects can be divided into the following categories:
                                          Automation asset management approach 
                                          Role-based access policies
                                          User authentication and management
                                          App connections & data security
                                          Audit and compliance management
      Automation lifecycle management is a series of steps that teams can follow, from discovering automation ideas to implementing and running them in production. 
ENABLE
      Resource Center enables builders and provides general useful information about the automation practice for those involved or interested in knowing more. It makes resources easily available to everyone on whatever internal website or collaboration platform the company uses.
      Onboarding and Education provide users and builders with what they need to be successful and contribute quickly and effectively to the automation practice.
      Accelerators & Reusable Assets, including commonly used patterns, use cases, and functionality enable even faster development of solutions as well as templating of standards and best practices.
ADOPT
      Value Reporting is about adopting a systemic and consistent approach to quantify the impact of automation by involving  different forms of Key Performance Indicators such as: 
               Operational Cost Savings 
               Revenue Impact 
               Risk & Compliance
      Champions & Evangelism focuses on spreading the word about how automation can solve business problems and the value that it can bring.
      Community is an important tool to build collaboration and develop a culture of automation by providing a program for guidance and practical experience, idea exchange, and fostering connections across team.
RUN 
      Project Execution with a low-code/no-code development approach, the Workato platform is built to deliver with speed and agility. Adopting lean automation with a Scrum-based  Agile delivery approach can complement 
                  the platform capabilities and gives a quick turnaround to deploy, execute the pilot and convert it into a production version.
      Capacity Planning is the practice of calculating (and predicting) the required capacity (either the number of recipes or task consumption) to support ongoing and future initiatives.
      Support Models describe the different channels any given user can leverage for:
                     Development support (e.g. if they get stuck on a particular recipe) 
                     Product support (e.g. automation breaks or bugs found)
            Support Levels: 
                     [Level 0] Self-support: Enabled through crowd-sourcing (e.g. Slack channels, community forums) and self-serve (e.g. knowledge hubs or Workato Chat support)
                     [Level 1] Ops team: Formal process to log a ticket to the internal central Ops Team for assistance
                     [Level 2] Workato support: Formal process to log a support ticket with Workato. Ideally, tickets will be created by the central Ops Team
                     [Level 3] Workato escalation: Formal process to escalate critical open support tickets through assigned CSM
      Operations lever focuses on the day to day operational activities related to running an enterprise automation platform. These are the main focus areas that need to be addressed:
                  Monitoring. Proactive and reactive tracking of production assets
                  Log aggregation strategy
                  Analytics
                  Error handling and Notifications
                  Concurrency and Performance   
SCALE
      Automation Maturity & Improvement lever, a maturity level is used as an assigned grade with predetermined sets of criteria to evaluate the various parameters impacting the performance of enterprise automation practice.
      Automation Discovery is a  journey. To keep the momentum going and make automation core to optimizing operations and driving business value, it's imperative to have a consistent pipeline of potential automation candidates. 
      Enterprise Automation Ecosystem lever focuses on how an Enterprise Automation platform fits within the Business Technology integration and automation tech stack ecosystem. While Enterprise Automation should cover the vast majority of scenarios
                     for wall-to-wall automations, the reality is that there 
               are multiple cases that will require a specialized platform to work in tandem with the Enterprise Automation Platform. 
Phased approach to automation at scale:
      Incubation: start small with an Automation First Mentality             
      Acceleration:Grow organically through an Automation Factory
      Institutionalization: Become faster over time with Automation at scale


On-Prem Agent overview:

OPA: ON-Premise, has been exclusively used to refer to software that is deployed onto infrastructure that is fully controlled by an organization such as physical servers and datacenters.
On-Prem is required in order to allow users of workato to build out recipes which need to communicate with on-prem applications securely.
OPA Features:
         Secure Tunnel: Resides inside the corporate firewall. 
                        communicating using standard ports.
         Complete control: Fully controlled and administered by customers.
         Extensible : OPA SDK to extend functionality eg: custome authentication.

         

Introduction to Connector SDK



A connector allows Workato to interact with a single application through a series of triggers and actions. 
Triggers monitor for events that occur in the application you hope to connect to and kickstart a workflow of actions that we call recipes. 
Actions carry out specific pre-defined operations in the target application.
What is Connector SDK?
                  Workato's Connector Software Development Kit, or SDK, is a powerful tool that allows you to build and deploy custom connectors to:
                                       Provide connectivity when there are no out-of-the-box (OOB) connectors available for your use case
                                       Support a wide range of authentication methods
                                       Create triggers to pick up new events via webhooks or at frequent polling intervals
                                       Build actions and pull/push data into an application
                                       Design a recipe-building experience for your team members down to the very last detail
                                       Leverage other Workato such as on-premise agents
custom connectors are built just once but they are reusable and customizable for multiple recipes.
Workato has a variety of features and functionalities and over a thousand OOB connectors to help you automate efficiently and effectively.
            Custom connectors provide advanced flexibility.
            Custom connectors also have a private scope by default which means that they are only visible and available to the connector owner. 
            Custom connectors are built just once but they are reusable and customizable for multiple recipes.
We recommend going through the following steps with both a product manager and a developer to ensure the needs of your customers are met.
            Detail your integration use cases
            Define your base set of objects
                     As a start, we would recommend shortlisting 4 or 5 objects which you want to interact with through a recipe in Workato.
            Explore possible actions and triggers
                     The best connectors often have 2 to 3 actions and triggers which focus on core use cases that you want to achieve. You can always iterate and enhance the connector over time for every use cases as needs expand.
            Review your connector plan
The Workato Connector SDK platform uses Code Mirror for editing your connector code. When writing your connector code, you can see all syntax or code errors in real time. Any connector source code you write on the SDK platform will be 
hosted in Workato's servers and is executed whenever a recipe using that connector is triggered.
Throughout the entire custom connector process, you will be able to build, test, and release your custom connector directly from Workato's platform. This means working directly from the browser you have open 
right now and never having to install anything onto your computer.
Let's take a look at some common key-value pairs in a custom connector:
      Connection: Connection configuration. 
      Test: Executed to verify whether a connection has successfully been made.
      Actions: Define actions and input fields for users to fill up.
      Triggers: Start recipes and can either be implemented via polling (checking every few minutes) or webhooks (static or dynamic).
      Object_definitions: Define commonly used input or output fields and reference them later on in your actions and triggers.
      Pick_lists: This is where you can define lists of values
      Methods: Functions which can be called from anywhere in the connector
Workato schema: It is one of the building blocks of your custom connector.
Lambda Functions: Each lambda function in Connector SDK receives arguments that can be used when you are defining the function's behavior. 
Lambda functions are critical pieces of any custom sonnectors used to build your input and ouput fields for your custom connectors.
They are defined by a "Lambda do" and "End" any code must be defined in b/w
The Connection Block: handles everything related to your connection via three keys:
            fields : allows the what inputs user of your connectors will need to give
                     2 fields 
                           API Key
                           Domain
            authorization: whatever logic needed to make the sucessful connection
                                 accepts a hash which can have multiple keys:
                                          type : tell about the what type of authentication is connection uses.
                                          apply: where to place token user name and passwords and API keys
            base_uri: optional and dectates the API base URL
                        Accepts a lambda function with one argument. this argument ("Connect") allows you to refernece the user's given input defined in "fields".
                        All other HTTP requests in the connectors can be defined as relative paths after this.
                        Test key is a root level attribute of your custome connector.
Basic authentication: Typically, a basic authentication requires a username and password combination when making requests. Make sure to include those two fields in the connection fields definition.
API Key: API key authentication is an authentication method that traditionally asks users to generate API keys in the application that they want to connect to. This API key 
         may be scoped to the permissions of the user generating them or permissions could be configured on a key by key basis.                          
OAuth 2.0: The OAuth 2.0 Authorization code flow is a way for Workato to impersonate a specific user when authenticating to an API. This is done by getting the user's consent via a browser popup when they first attempt to connect.
           With OAuth 2.0 Auth, you can define the authorization url. This url could also include additional information such as scope.
           Some notes about OAuth 2.0:
                        The acquire key is a lambda function that is invoked after we receive the OAuth2 callback from the API. Normally you can make the second call to the token endpoint from here.
                        We have also defined additional keys to handle the refresh token. Scroll down to the next section to find the relevant guides corresponding to each type of OAuth2 variant we support.
Custom auth: Custom auth allows you to handle almost any type of authentication by telling the console on exactly what to do.



The Application Provisioning/ Deprovisioning Accelerator


The Application Provisioning/Deprovisioning (APD) Accelerator helps organizations to fully automate the process of  adding, updating, or removing user access to applications when an employee is on-boarded or offboarded.


Autonomous operations framework accelerator


The AOF Accelerator is a pre-packaged solution that provides a consistent and efficient error-handling solution for businesses managing ten or more recipes, across multiple use cases.
AOF Functions: 
              Error logging and visibility to ensure that there is visibility on errors encountered within recipes and can be leveraged for analyzing errors and taking corrective measures. 
              Automated recovery from transient errors without human intervention such as errors related to the API rate limits or temporary unavailability of host servers.
              Notifications & alerting ensure that the relevant persons are notified through the appropriate channels whether it be a channel on Slack, email, creating a ticket, or another application.
              Periodic job reports utilize the Error Collation mechanism, which will talk about in a future lesson, to scrape specific recipes’ job history and provide consolidated reports as CSV files.
The RecipeOps connector is essential in that it enables the building of recipes to monitor and manage active recipes. 


Collection by Workato:

Collection provide you with actions that you can start working with such as 
            Creating list in collections
            creating list in collection from csv file 
            Query lists in collection
Collection work like a database where it can store lists, which correspond to databse table.
collection by workato is List by workato on steroids.
Robust native application
Manipulate table data
Synchronize related data across multiple systems
mutable and searchable lists
functions like a temporary SQL database
         Supports statement in SQL syntax
         Corresponds to a database table
         Works with large datasets
         only available within the job they are created in
Creating lists on collections:
Collection list action creates a collection list in the recipe from a list input.
Querying list 
         This action allows you to perform standard SQL queries on your lists.
         Queries are used to find specific data by filtering explicit criteria and also help in manipulationg tons of data in an easy and quick way.
Modifiying list: 
         you can use the query list action to modify the list with insert or update query.
Common mistakes :
         Debugging
Using a nested input list will cause an internal error when trying to create a collection.
similar to databases, the 2D table only takes in non-nested data.
Instead, use Mapper by workato to remap you suorce data into a flat first before creating a collection with it.
Column names in your collection list cannot have spaces.


OPA(on-prem Agent) manager:

Workato’s OPA Manager Accelerator, or OPM Accelerator, provides a set of recipes which manages OPA’s across multiple networks.
Enterprises having multiple OPAs have to go through many manual tasks to manage OPAs.
No server access is required for a user to manage OPAs or retrieve troubleshooting logs.
The manifest contains 14 recipes:
         4 Slackbot recipes
         10 functional callable recipes
         1 scheduler recipe
Connector SDK
The OPM Accelerator package includes one Connector SDK called the Workato On-Prem API.
There are three ways to connect your OPM Scripts.
         OPM Scripts connection for Windows environment
         OPM Scripts connection for Linux environment
         On Prem Scripts API Connection
The On Prem Scripts API is used to access Workato on-prem API features and gives you the ability to work with On-prem Groups and On-prem Agents.
Once we have our scripts connected, we can start our recipes in the following order:
                  Diagnostic recipes
                  File management recipes
                  Installatime management recipes
                  Runtime management recipes
                  Slack command recipes
                  


Enterprise Data Hub


Workato’s Enterprise Data Hub (EDH) Accelerator provides a robust solution for efficiently managing your organization’s key master records and ensuring you have a single trusted source for this data that remains cleansed, enriched, and always up-to-date using near real-time data synchronization.
The EDH Accelerator includes a collection of prebuilt recipes, starter data models, an easy to use connector, and a configurable schema and provides:
         Pre-built integrations with Snowflake/SQL Server/PostgreSQL and various data sources to rapidly centralize, enrich, and cleanse data to be leveraged across the company.
         Data validation rules & triggers for configuration-based data validation for all ingested records and triggers to notify stakeholders of potential issues.
         Customizable data models that are usable out-of-the-box but can be tailored for your organization’s Customer 360 or Employee Data Hub projects.
EDH Accelerator uses 8 API recipes, 9 callable recipes, and 2 active recipes,  which if utilized, may impact the costs of Workato for regular billing cycles.



Error Troubleshooting


Recipe design errors: refers to errors caught while building recipes
Errors will show when the user click on test or start recipe.
         Missing required input fields
         formula errors
         invalid datapills
         App connection errors
Trigger errors:Trigger errors occur when the recipe tries to retrieve trigger events by polling the trigger app, but fails to fetch trigger events successfully. 
As no trigger event data was retrieved, the recipe does not create a job in the first place. 
There are different causes of why a trigger error occurs:
Type of Cases:
         When connection becomes invalid
         When connected user does not have right permissions to retrieve trigger events
         When API call times out
         When trigger filters are logically incorrect or too restrictive
         Automatically stopped after 60 trigger errors
401: App connection becomes invalid and the recipe is unable to connect successfully to the trigger app to fetch trigger events.
Reconnect successfully to trigger application.
403: Connected user does not have the right permissions to fetch trigger events  
Update the connected user's permissions to provide required read/write permission scopes.
schema errors: Recipe makes an invalid API call, e.g. due to schema changes such as field deletion in the app that wasn't reflected in the recipe    
Carry out a schema refresh for the recipes with schema errors.
timeout error: Recipe makes an API call that times out while waiting for trigger events to be fetched. This is usually transient, i.e. the API server might be experiencing temporary downtime
If transient, you should stop getting the error after a while. If an error keeps occurring, check the API uptime status of the app that the recipe keeps failing at, or reach out to your Customer Success Manager.
Recipe encounters 60 successive action errors that are identified by Workato as an unauthorized error, rate limit error or schema error.
Recipe will automatically be stopped.
What are Jobs?
When an active recipe processes a trigger event. (i.e. actions in the recipe are executed, it results in a job)
The job report is a record of all processed jobs. For each processed job, you can view complete details.
Each job consists of a trigger event and the sequence of actions is carried out, according to the recipe logic. This set and sequence of actions executed depend on the data of the specific trigger event.
Job errors, also known as recipe execution errors, usually occur when a trigger event has been found, and a job is being processed, therefore typically showing up as recipe job errors. 
404 Not Found: The record that you're trying to execute the action cannot be found (e.g Get, Update, Delete)
415 Unsupported Media Type Errors: This indicates that the app refused to accept the request because of the payload format is in an unsupported format.
400/422 Errors: There are multiple reasons why you encounter a 400 bad request.  This could be due to creating a duplicate record, Invalid data may have been passed in etc.
429 Too Many Requests Errors: This HTTP response status code indicates that the user has sent too many requests in a given amount of time.
500: This status code 500 is a generic error response. This means that the server encountered an unexpected condition that prevented it from fulfilling the request. 
When there is no other error code suitable, this error code is usually returned.
Recipe logic errors:the logic of your recipe makes or break your integration solution.
            Incorrect recipe step indentations
                     the indented steps under IF steps will only be carried out when the condition is met.
                     indented steps under Repeat steps will be carried out for the records in the list.
                     not indented steps will be executed when the recipe is started/tested.
            Incorrect list management
                     This logic error is seen when your recipe job seems to iterate through the list, but does not retrieve the different data from the list objects.
            infinite looping
                     Infinite loops is when it continuously fetching triggers events, even if no activity in your trigger app.
                     single recipe infinte looping can occur when a recipe trigger monitors updates in the same object that it updates in an action.
                     best practice is to create custom fields that are meant for identifying jobs synced by workato when doing bi-directional syncs.
                     solution: Filtering out by using an integration user as a condition. 
            unexpected trigger events(data duplication)
            Missing trigger events
                   that you may be experiencing no trigger events in your active recipe.
                   trigger condition doesn't matches the event that is being implemented in the application.
                   There are 3 possible trigger events:
                              New record trigger: records are solely created.
                              New/updates record trigger: monitors for any update to a record or when a record is newly created
                              Updated record trigger: records only updated, now new record is made.



Task Optimization

Every timde a recipe invkoes an action provided by a connector it counts as one task.
Action in app   call recipe --- one task per step
if/else condition   repeat action   handle errors --- not a task
key factors of task usage:
1. no of jobs
2. no of events per job
3. efficient processing of events
Task Optimization Approach:
identify 
assess
optimize
Task Optimization strategies:
Trigger strategies:
         Polling Frequency
         Trigger conditions
         Batch/bulk triggers
Batch/bulk Strategies
         Batch/bulk
         Filtering events
         Delta SYnc
         ELT pipeline
         Streaming
Effiency Strategies:
         Formula mode
         List processing
         collections
         Custom code
         variable grouping
         variable declarations
         Response catching
         custom SDK


API Platform

API stands for Application Programming Interface, which is a mechanism that allows two applications to exchange information using a set of rules.
an API provides the ability to interact with applications from within other applications.
The following is the Anatomy of a typical REST API:
1. endpoint: The Endpoint is the Address that you'd like to send your request or make a call to. 
2. resource: Resource refers to the type of info that the API is tagged with/to. 
3. Method: The method defines the operation with the resource and the allowed interaction with the resource.
            GET	Get a resource from the server
            POST	Create a resource to the server
            PATCH/PUT	Update existing resource on the server
            DELETE	Delete existing resource from the server
4. Request Body?Query Params: Query parameters give you the option to modify your request with key-value pairs. Usually in the URL, 
                              Query Parameters appears after the question mark (?) and each parameter pair is separated with an ampersand (&).
5. Headers: Headers are additional details provided for communication between the client and the server.
            The most common types of headers are:
                 Authorization	Contains the authentication credentials for HTTP authentication.
                 Content-Type	   Tells the client what media type (
6. Response body: Response body contains information about the output and additional output ports.
7. HTTP status codes: A status code is a three-digit integer. The first digit identifies the general category of response.
                        Status       Code	Description
                           1xx	indicates an information message only
                           2xx	 indicates success of some kind
                           3xx	redirects the client to another URL
                           4xx   indicates an error on the client's part
                           5xx	indicates an error on the server's part











